// apiService.js - Servi√ßo centralizado para abstrair APIs do Electron e Web
import environmentDetector, { isElectron, isWeb, waitForElectronAPIs } from '../utils/environmentDetector.js';
import { devLog } from './devLog.js';

class ApiService {
    constructor() {
        this.capabilities = null;
        this.isReady = false;
        this.initPromise = this.init();
    }

    async init() {
        devLog('üîß API Service: Inicializando...');

        this.capabilities = await environmentDetector.getCapabilities();
        this.isReady = true;

        devLog('üîß API Service: Capacidades:', this.capabilities);

        // SOLU√á√ÉO ROBUSTA: Configura√ß√£o espec√≠fica para Electron
        if (this.capabilities.isElectron || (window.electronAPI && window.electronAPI.isElectron && window.electronAPI.isElectron())) {
            devLog('üîß API Service: Ambiente Electron detectado - aplicando configura√ß√£o espec√≠fica');

            // ‚úÖ SOLU√á√ÉO DEFINITIVA: Configura√ß√£o otimizada para APIs
             devLog('üîß API Service: Aplicando configura√ß√£o otimizada para APIs...');

             // Configura√ß√£o imediata baseada na disponibilidade atual
             this.capabilities.hasVideoAPI = !!(window.electronAPI?.video?.getVideoUrl);
             this.capabilities.hasSystemAPI = !!(window.electronAPI?.system?.getSystemInfo || window.electronAPI?.system?.getSystemInfoSync);
             this.capabilities.hasFileAPI = !!(window.electronAPI?.system?.fileExists || window.electronAPI?.system?.fileExistsSync);

             devLog('‚úÖ API Service: Configura√ß√£o aplicada:', this.capabilities);

             // ‚úÖ VALIDA√á√ÉO ASS√çNCRONA: Verifica√ß√£o em segundo plano (n√£o bloqueante)
             this.validateAPIsAsync();

                // Configura√ß√£o otimista - assumir que APIs estar√£o dispon√≠veis
                if (window.electronAPI) {
                    this.capabilities.hasVideoAPI = !!(window.electronAPI?.video?.getVideoUrl);
                    this.capabilities.hasSystemAPI = !!(window.electronAPI?.system?.getSystemInfo || window.electronAPI?.system?.getSystemInfoSync);
                    this.capabilities.hasFileAPI = !!(window.electronAPI?.system?.fileExists || window.electronAPI?.system?.fileExistsSync);

                    devLog('‚úÖ API Service: Configura√ß√£o otimizada aplicada:', this.capabilities);
                }
        }

        return this.capabilities;
    }

    // ‚úÖ VALIDA√á√ÉO ASS√çNCRONA N√ÉO BLOQUEANTE
    validateAPIsAsync() {
        setTimeout(async () => {
            try {
                devLog('üîç API Service: Iniciando valida√ß√£o ass√≠ncrona das APIs...');

                // Aguardar um tempo maior para garantir que tudo esteja carregado
                await new Promise(resolve => setTimeout(resolve, 1000));

                // Re-verificar capacidades ap√≥s delay
                const currentHasVideoAPI = !!(window.electronAPI?.video?.getVideoUrl);
                const currentHasSystemAPI = !!(window.electronAPI?.system?.getSystemInfo || window.electronAPI?.system?.getSystemInfoSync);
                const currentHasFileAPI = !!(window.electronAPI?.system?.fileExists || window.electronAPI?.system?.fileExistsSync);

                // Atualizar capacidades se houver mudan√ßas
                if (currentHasVideoAPI !== this.capabilities.hasVideoAPI) {
                    devLog('üîÑ API Service: hasVideoAPI atualizado:', currentHasVideoAPI);
                    this.capabilities.hasVideoAPI = currentHasVideoAPI;
                }

                if (currentHasSystemAPI !== this.capabilities.hasSystemAPI) {
                    devLog('üîÑ API Service: hasSystemAPI atualizado:', currentHasSystemAPI);
                    this.capabilities.hasSystemAPI = currentHasSystemAPI;
                }

                if (currentHasFileAPI !== this.capabilities.hasFileAPI) {
                    devLog('üîÑ API Service: hasFileAPI atualizado:', currentHasFileAPI);
                    this.capabilities.hasFileAPI = currentHasFileAPI;
                }

                devLog('‚úÖ API Service: Valida√ß√£o ass√≠ncrona conclu√≠da:', this.capabilities);

            } catch (error) {
                devLog('‚ö†Ô∏è API Service: Erro na valida√ß√£o ass√≠ncrona:', error.message);
            }
        }, 500);
    }

    async waitUntilReady() {
        if (!this.isReady) {
            await this.initPromise;
        }
        return this.isReady;
    }

    // ‚úÖ SOLU√á√ÉO DEFINITIVA: API de v√≠deo refatorada com abordagem resiliente
    async getVideoUrl(filePath) {
        await this.waitUntilReady();

        devLog('üé• API Service: Obtendo URL para v√≠deo (sistema refatorado):', filePath);

        // ‚úÖ ABORDAGEM 1: Verifica√ß√£o r√°pida de contexto (sempre funciona)
        const contextCheck = this.checkVideoContext(filePath);
        if (!contextCheck.valid) {
            devLog('‚ö†Ô∏è API Service: Contexto de v√≠deo inv√°lido:', contextCheck.reason);
            throw new Error(`Contexto inv√°lido: ${contextCheck.reason}`);
        }

        // ‚úÖ ABORDAGEM 2: Tentar API do Electron com seguran√ßa m√°xima
        if (this.isVideoAPIReady()) {
            try {
                const electronUrl = await this.getElectronVideoUrl(filePath);
                if (electronUrl) {
                    devLog('‚úÖ API Service: URL obtida via Electron:', electronUrl);
                    return electronUrl;
                }
            } catch (error) {
                devLog('‚ö†Ô∏è API Service: API do Electron falhou:', error.message);
            }
        }

        // ‚úÖ ABORDAGEM 3: √öltimo recurso - erro informativo
        console.error('‚ùå API Service: N√£o foi poss√≠vel obter URL do v√≠deo');
        throw new Error('V√≠deo n√£o dispon√≠vel - verifique se o arquivo existe e as APIs est√£o funcionando');
    }

    // ‚úÖ SOLU√á√ÉO DEFINITIVA: Implementa√ß√£o h√≠brida para verifica√ß√£o de arquivos
    async fileExists(filePath) {
        await this.waitUntilReady();

        devLog('üìÑ API Service: Verificando se arquivo existe:', filePath);

        // Estrat√©gia 1: Tentar vers√£o s√≠ncrona primeiro (mais r√°pida e confi√°vel)
        if (window.electronAPI?.system?.fileExistsSync) {
            try {
                devLog('üìÑ API Service: Usando vers√£o s√≠ncrona...');
                const exists = window.electronAPI.system.fileExistsSync(filePath);
                devLog('üìÑ API Service: Arquivo existe (s√≠ncrono):', exists);
                return exists;
            } catch (error) {
                devLog('‚ö†Ô∏è API Service: Vers√£o s√≠ncrona falhou:', error.message);
            }
        }

        // Estrat√©gia 2: Tentar vers√£o ass√≠ncrona
        if (window.electronAPI?.system?.fileExists) {
            try {
                devLog('üìÑ API Service: Usando vers√£o ass√≠ncrona...');
                const exists = await window.electronAPI.system.fileExists(filePath);
                devLog('üìÑ API Service: Arquivo existe (ass√≠ncrono):', exists);
                return exists;
            } catch (error) {
                devLog('‚ö†Ô∏è API Service: Erro ao verificar arquivo:', error.message);
            }
        }

    }

    // ‚úÖ SOLU√á√ÉO DEFINITIVA: Implementa√ß√£o h√≠brida para informa√ß√µes do sistema
    async getSystemInfo() {
        await this.waitUntilReady();

        devLog('üñ•Ô∏è API Service: Obtendo informa√ß√µes do sistema');
        devLog('üñ•Ô∏è API Service: Estado atual das APIs:', {
            hasElectronAPI: !!window.electronAPI,
            hasSystemAPI: !!window.electronAPI?.system?.getSystemInfo,
            hasSystemAPISync: !!window.electronAPI?.system?.getSystemInfoSync,
            isElectron: this.capabilities?.isElectron
        });

        // Estrat√©gia 1: Tentar vers√£o s√≠ncrona primeiro (mais r√°pida)
        if (window.electronAPI?.system?.getSystemInfoSync) {
            try {
                devLog('üñ•Ô∏è API Service: Usando vers√£o s√≠ncrona...');
                const info = window.electronAPI.system.getSystemInfoSync();
                devLog('‚úÖ API Service: Informa√ß√µes obtidas (s√≠ncrona)');
                return info;
            } catch (error) {
                devLog('‚ö†Ô∏è API Service: Vers√£o s√≠ncrona falhou:', error.message);
            }
        }

        // Estrat√©gia 2: Tentar vers√£o ass√≠ncrona
        if (window.electronAPI?.system?.getSystemInfo) {
            try {
                devLog('üñ•Ô∏è API Service: Usando vers√£o ass√≠ncrona...');
                // Aguardar um pouco para garantir que o contexto esteja totalmente carregado
                await new Promise(resolve => setTimeout(resolve, 100));

                const info = await window.electronAPI.system.getSystemInfo();
                devLog('‚úÖ API Service: Informa√ß√µes obtidas (ass√≠ncrona)');
                return info;
            } catch (error) {
                devLog('‚ö†Ô∏è API Service: Erro ao obter informa√ß√µes do sistema:', error.message);
            }
        }

        // Estrat√©gia 3: Retornar informa√ß√µes b√°sicas do navegador como √∫ltimo recurso
        try {
            devLog('üñ•Ô∏è API Service: Usando informa√ß√µes b√°sicas do navegador...');
            const info = {
                platform: 'web',
                arch: 'unknown',
                totalMemory: 'unknown',
                freeMemory: 'unknown',
                cpus: navigator.hardwareConcurrency || 'unknown',
                userAgent: navigator.userAgent
            };
            devLog('‚úÖ API Service: Informa√ß√µes b√°sicas obtidas');
            return info;
        } catch (error) {
            console.error('‚ùå API Service: Todas as estrat√©gias falharam:', error);
            return null;
        }
    }

    // Servi√ßo de V√≠deo Universal (funciona em ambos ambientes)
    async getVideoSource(filePath) {
        await this.waitUntilReady();

        devLog('üé¨ API Service: Obtendo fonte de v√≠deo para:', filePath);

        // ‚úÖ DIAGN√ìSTICO DETALHADO: An√°lise completa do estado atual
        const currentState = {
            // Estado das capacidades
            capabilities: this.capabilities,

            // Estado em tempo real das APIs
            realTime: {
                hasElectronAPI: !!window.electronAPI,
                hasVideoAPI: !!(window.electronAPI?.video?.getVideoUrl),
                hasSystemAPI: !!(window.electronAPI?.system?.getSystemInfo || window.electronAPI?.system?.getSystemInfoSync),
                hasFileAPI: !!(window.electronAPI?.system?.fileExists || window.electronAPI?.system?.fileExistsSync),
                isElectronFunction: !!(window.electronAPI && window.electronAPI.isElectron && window.electronAPI.isElectron())
            },

            // Contexto de execu√ß√£o
            context: {
                apiServiceReady: this.isReady,
                filePath: filePath,
                filePathType: typeof filePath,
                filePathValid: filePath && typeof filePath === 'string' && filePath.length > 0
            },

            // Ambiente de execu√ß√£o
            environment: {
                isElectron: this.capabilities?.isElectron,
                userAgent: navigator.userAgent,
                platform: typeof process !== 'undefined' && process.platform ? process.platform : 'browser',
                nodeEnv: typeof process !== 'undefined' && process.env && process.env.NODE_ENV ? process.env.NODE_ENV : 'development'
            }
        };

        devLog('üé¨ API Service: Diagn√≥stico completo:', currentState);

        // ‚úÖ SOLU√á√ÉO DEFINITIVA: Sistema inteligente de decis√£o para v√≠deo
         devLog('üé¨ API Service: Iniciando an√°lise inteligente de v√≠deo...');

         // Verifica√ß√£o em tempo real da disponibilidade da API
         const hasVideoAPI = !!(window.electronAPI?.video?.getVideoUrl);
         const hasSystemAPI = !!(window.electronAPI?.system?.getSystemInfo || window.electronAPI?.system?.getSystemInfoSync);

         devLog('üé¨ API Service: Estado atual das APIs:', {
             hasVideoAPI,
             hasSystemAPI,
             isElectron: this.capabilities?.isElectron,
             apiServiceReady: this.isReady
         });

         // ‚úÖ FOR√áA BRUTA: Tentar API de v√≠deo independentemente do estado inicial
          devLog('üî• API Service: Tentativa FOR√áA BRUTA - ignorando estado inicial');
 
          try {
              // Tentar diretamente sem verificar capacidades
              const url = await this.getVideoUrl(filePath);
              if (url && url.startsWith('http://localhost:')) {
                  devLog('‚úÖ API Service: SUCESSO! V√≠deo carregado via for√ßa bruta');
                  return { type: 'electron-http', url, source: 'Electron HTTP Server' };
              }
          } catch (error) {
              devLog('‚ö†Ô∏è API Service: For√ßa bruta falhou:', error.message);
          }
 
         // ‚úÖ VERIFICA√á√ÉO ADICIONAL COM DELAY: √öltima tentativa
          devLog('üîÑ API Service: √öltima tentativa com delay adicional...');
          await new Promise(resolve => setTimeout(resolve, 1000));
 
          try {
              const url = await window.electronAPI.video.getVideoUrl(filePath);
              if (url && url.startsWith('http://localhost:')) {
                  devLog('‚úÖ API Service: SUCESSO na √∫ltima tentativa!');
                  return { type: 'electron-http', url, source: 'Electron HTTP Server' };
              }
          } catch (error) {
              devLog('‚ö†Ô∏è API Service: √öltima tentativa falhou:', error.message);
          }

         // ‚úÖ Fallback inteligente apenas se APIs cr√≠ticas estiverem dispon√≠veis
         if (hasSystemAPI) {
             devLog('‚ö†Ô∏è API Service: V√≠deo n√£o dispon√≠vel, mas sistema operacional - retornando erro informativo');
             return {
                 type: 'electron-error',
                 url: null,
                 source: 'Video API Unavailable',
                 message: 'API de v√≠deo n√£o est√° dispon√≠vel. Verifique se o processo principal do Electron est√° funcionando.',
                 error: 'VIDEO_API_UNAVAILABLE',
                 requiresServer: true,
                 originalPath: filePath,
                 troubleshooting: 'Verifique se o handler get-video-url est√° registrado no main process'
             };
         }

        // Fallback apenas se realmente n√£o estiver no Electron
        devLog('üé¨ API Service: Usando m√©todo alternativo (n√£o-Electron ou APIs indispon√≠veis)');
        return this.getWebVideoSource(filePath);
    }

    async getWebVideoSource(filePath) {
        // SOLU√á√ÉO ROBUSTA: Nunca usar file:// URLs no Electron
        if (this.capabilities.isElectron || (window.electronAPI && window.electronAPI.isElectron && window.electronAPI.isElectron())) {
            devLog('üö´ API Service: BLOQUEANDO file:// URL no ambiente Electron');

            return {
                type: 'electron-error',
                url: null,
                source: 'Electron File URL Blocked',
                message: 'URLs file:// s√£o bloqueadas no Electron. Use o servidor HTTP interno.',
                error: 'FILE_URL_BLOCKED',
                requiresServer: true,
                originalPath: filePath
            };
        }

        if (isWeb()) {
            devLog('üåê API Service: Ambiente Web detectado');

            // Em ambiente web, precisamos converter o arquivo para blob URL
            return {
                type: 'web-upload',
                url: null,
                source: 'Web Upload Required',
                message: 'Por favor, fa√ßa upload do v√≠deo para uso na web',
                requiresUpload: true,
                originalPath: filePath
            };
        }

        // √öltimo recurso - tentar file:// mas com aviso claro
        devLog('‚ö†Ô∏è API Service: Usando file:// como √∫ltimo recurso - pode falhar');
        const fileUrl = 'file://' + filePath;
        return {
            type: 'file-url',
            url: fileUrl,
            source: 'Direct File URL (√öltimo Recurso)',
            warning: 'Pode n√£o funcionar devido a restri√ß√µes de seguran√ßa'
        };
    }

    // Controles da Janela (Electron apenas)
    minimizeApp() {
        if (this.capabilities.isElectron && window.electronAPI?.minimizeApp) {
            window.electronAPI.minimizeApp();
        }
    }

    maximizeApp() {
        if (this.capabilities.isElectron && window.electronAPI?.maximizeApp) {
            window.electronAPI.maximizeApp();
        }
    }

    closeApp() {
        if (this.capabilities.isElectron && window.electronAPI?.closeApp) {
            window.electronAPI.closeApp();
        }
    }

    forceQuitApp() {
        if (this.capabilities.isElectron && window.electronAPI?.forceQuitApp) {
            window.electronAPI.forceQuitApp();
        }
    }

    onAppClosing(callback) {
        if (this.capabilities.isElectron && window.electronAPI?.onAppClosing) {
            window.electronAPI.onAppClosing(callback);
            // Retorna uma fun√ß√£o para remover o listener, para limpeza
            return () => window.electronAPI.removeAllListeners('app-closing');
        }
        // Retorna uma fun√ß√£o vazia para o ambiente web
        return () => {};
    }

    // APIs de Projeto
    async saveProject(projectData, filePath) {
        await this.waitUntilReady();

        if (this.capabilities.isElectron && window.electronAPI?.project?.saveProject) {
            try {
                return await window.electronAPI.project.saveProject(projectData, filePath);
            } catch (error) {
                console.error('üíæ API Service: Erro ao salvar projeto:', error);
                throw error;
            }
        } else {
            // Em ambiente web, fazer download
            return this.saveProjectWeb(projectData);
        }
    }

    saveProjectWeb(projectData) {
        devLog('üíæ API Service: Salvando projeto como download web');

        const dataStr = JSON.stringify(projectData, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });

        const url = URL.createObjectURL(dataBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `${projectData.name || 'project'}.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);

        return { success: true, method: 'web-download' };
    }

    // Utilidades
    getCapabilities() {
        return { ...this.capabilities };
    }

    isReady() {
        return this.isReady;
    }

    getEnvironmentMessage() {
        if (this.capabilities?.isElectron) {
            if (this.capabilities.hasVideoAPI && this.capabilities.hasSystemAPI) {
                return '‚úÖ Ambiente Electron com APIs completas';
            } else {
                return '‚ö†Ô∏è Ambiente Electron com APIs limitadas';
            }
        } else {
            return 'üåê Ambiente Web (funcionalidade limitada)';
        }
    }

    // ‚úÖ SOLU√á√ÉO DEFINITIVA: Sistema completamente refatorado para informa√ß√µes do sistema (m√©todo principal j√° existe acima)

    // ‚úÖ NOVA L√ìGICA: Verificar se contexto Electron est√° completamente pronto
    isElectronContextReady() {
        try {
            // Verifica√ß√£o m√≠nima de disponibilidade
            if (!window.electronAPI?.system) {
                return false;
            }

            // Verifica√ß√£o de pelo menos uma fun√ß√£o dispon√≠vel
            const hasSyncAPI = typeof window.electronAPI.system.getSystemInfoSync === 'function';
            const hasAsyncAPI = typeof window.electronAPI.system.getSystemInfo === 'function';

            if (!hasSyncAPI && !hasAsyncAPI) {
                return false;
            }

            devLog('‚úÖ API Service: Contexto Electron verificado e pronto');
            return true;

        } catch (error) {
            devLog('‚ö†Ô∏è API Service: Erro na verifica√ß√£o do contexto Electron:', error.message);
            return false;
        }
    }

    // ‚úÖ NOVA L√ìGICA: Obter informa√ß√µes locais imediatas (sempre funciona)
    getLocalSystemInfo() {
        const info = {
            platform: 'browser',
            arch: 'javascript',
            cpus: typeof navigator !== 'undefined' ? navigator.hardwareConcurrency || 1 : 1,
            userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : 'Unknown',
            language: typeof navigator !== 'undefined' ? navigator.language : 'unknown',
            timestamp: Date.now(),
            source: 'local',
            isElectron: this.capabilities?.isElectron || false,
            screenResolution: typeof screen !== 'undefined' ? `${screen.width}x${screen.height}` : 'unknown',
            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone || 'unknown',
            onlineStatus: typeof navigator !== 'undefined' ? navigator.onLine : true
        };

        devLog('‚úÖ API Service: Informa√ß√µes locais geradas:', info);
        return info;
    }

    // ‚úÖ NOVA L√ìGICA: Tentar obter informa√ß√µes do Electron (com seguran√ßa m√°xima)
    async getElectronSystemInfo() {
        // Tentar vers√£o s√≠ncrona primeiro (mais r√°pida e segura)
        if (window.electronAPI?.system?.getSystemInfoSync) {
            try {
                devLog('üîÑ API Service: Tentando vers√£o s√≠ncrona...');

                // Verifica√ß√£o final de seguran√ßa
                if (typeof window.electronAPI.system.getSystemInfoSync !== 'function') {
                    throw new Error('Fun√ß√£o s√≠ncrona n√£o dispon√≠vel');
                }

                const info = window.electronAPI.system.getSystemInfoSync();

                if (info && info.platform) {
                    // Enriquecer informa√ß√µes locais com dados do Electron
                    const enrichedInfo = {
                        ...this.getLocalSystemInfo(),
                        ...info,
                        source: 'electron-sync',
                        enriched: true
                    };

                    devLog('‚úÖ API Service: Informa√ß√µes enriquecidas obtidas via Electron');
                    return enrichedInfo;
                }

            } catch (error) {
                devLog('‚ö†Ô∏è API Service: Vers√£o s√≠ncrona falhou:', error.message);
            }
        }

        // Tentar vers√£o ass√≠ncrona apenas se realmente necess√°rio
        if (window.electronAPI?.system?.getSystemInfo) {
            try {
                devLog('üîÑ API Service: Tentando vers√£o ass√≠ncrona...');

                // Delay m√≠nimo para garantir contexto
                await new Promise(resolve => setTimeout(resolve, 50));

                const info = await window.electronAPI.system.getSystemInfo();

                if (info && info.platform) {
                    // Enriquecer informa√ß√µes locais com dados do Electron
                    const enrichedInfo = {
                        ...this.getLocalSystemInfo(),
                        ...info,
                        source: 'electron-async',
                        enriched: true
                    };

                    devLog('‚úÖ API Service: Informa√ß√µes enriquecidas obtidas via Electron (ass√≠ncrono)');
                    return enrichedInfo;
                }

            } catch (error) {
                devLog('‚ö†Ô∏è API Service: Vers√£o ass√≠ncrona falhou:', error.message);
            }
        }

        devLog('‚ö†Ô∏è API Service: APIs do Electron n√£o funcionais');
        return null;
    }

    // ‚úÖ NOVA L√ìGICA: Fallback enriquecido como √∫ltimo recurso
    getEnhancedFallbackInfo() {
        try {
            const baseInfo = this.getLocalSystemInfo();

            // Adicionar informa√ß√µes adicionais √∫teis
            const enhancedInfo = {
                ...baseInfo,
                source: 'enhanced-fallback',
                message: 'Usando informa√ß√µes locais - APIs do sistema n√£o dispon√≠veis',
                fallbackReason: 'Electron APIs n√£o acess√≠veis',
                timestamp: Date.now(),
                hasElectronContext: !!window.electronAPI,
                hasSystemAPI: !!window.electronAPI?.system?.getSystemInfo,
                hasSystemAPISync: !!window.electronAPI?.system?.getSystemInfoSync,
                // Dados simulados para funcionalidades b√°sicas
                totalMemory: this.estimateMemory(),
                freeMemory: this.estimateMemory() * 0.6, // Estimativa de 60% dispon√≠vel
                nodeVersion: 'simulado',
                electronVersion: 'simulado',
                chromeVersion: 'simulado'
            };

            devLog('‚úÖ API Service: Fallback enriquecido gerado com sucesso');
            return enhancedInfo;

        } catch (error) {
            console.error('‚ùå API Service: Erro no fallback enriquecido:', error);
            return {
                platform: 'error',
                error: error.message,
                timestamp: Date.now(),
                source: 'error'
            };
        }
    }

    // ‚úÖ NOVA L√ìGICA: Estimativa de mem√≥ria baseada no ambiente
    estimateMemory() {
        try {
            // Tentar usar performance.memory se dispon√≠vel
            if (window.performance && window.performance.memory) {
                return Math.round(window.performance.memory.totalJSHeapSize / 1024 / 1024);
            }

            // Estimativa baseada no ambiente
            if (this.capabilities?.isElectron) {
                return 256; // Estimativa conservadora para Electron
            } else {
                return 128; // Estimativa para navegador
            }
        } catch {
            return 64; // Valor m√≠nimo seguro
        }
    }

    // ‚úÖ NOVA L√ìGICA: Verifica√ß√£o r√°pida de contexto de v√≠deo
    checkVideoContext(filePath) {
        try {
            if (!filePath || typeof filePath !== 'string') {
                return { valid: false, reason: 'Caminho do arquivo inv√°lido' };
            }

            if (!window.electronAPI) {
                return { valid: false, reason: 'API do Electron n√£o dispon√≠vel' };
            }

            return { valid: true };

        } catch (error) {
            return { valid: false, reason: `Erro na verifica√ß√£o: ${error.message}` };
        }
    }

    // ‚úÖ NOVA L√ìGICA: Verificar se API de v√≠deo est√° pronta
    isVideoAPIReady() {
        try {
            if (!window.electronAPI?.video?.getVideoUrl) {
                return false;
            }

            if (typeof window.electronAPI.video.getVideoUrl !== 'function') {
                return false;
            }

            devLog('‚úÖ API Service: API de v√≠deo verificada e pronta');
            return true;

        } catch (error) {
            devLog('‚ö†Ô∏è API Service: Erro na verifica√ß√£o da API de v√≠deo:', error.message);
            return false;
        }
    }

    // ‚úÖ NOVA L√ìGICA: Obter URL do v√≠deo via Electron com seguran√ßa m√°xima
    async getElectronVideoUrl(filePath) {
        try {
            devLog('üé• API Service: Tentando obter URL via Electron...');

            // Verifica√ß√£o final de seguran√ßa
            if (typeof window.electronAPI.video.getVideoUrl !== 'function') {
                throw new Error('Fun√ß√£o getVideoUrl n√£o dispon√≠vel');
            }

            // Delay m√≠nimo para garantir contexto
            await new Promise(resolve => setTimeout(resolve, 50));

            const url = await window.electronAPI.video.getVideoUrl(filePath);

            // Valida√ß√£o da URL retornada
            if (url && typeof url === 'string' && url.startsWith('http://localhost:')) {
                devLog('‚úÖ API Service: URL v√°lida obtida:', url);
                return url;
            } else {
                throw new Error('URL inv√°lida retornada pela API');
            }

        } catch (error) {
            devLog('‚ö†Ô∏è API Service: Erro ao obter URL do v√≠deo:', error.message);
            throw error;
        }
    }

    async getCpuUsage() {
        await this.waitUntilReady();
        if (this.capabilities.isElectron && window.electronAPI?.system?.getCpuUsage) {
            try {
                return await window.electronAPI.system.getCpuUsage();
            } catch (error) {
                devLog('üíª API Service: Erro ao obter uso de CPU:', error.message);
                return 'N/A';
            }
        }
        return 'N/A';
    }
}

// Criar inst√¢ncia global
const apiService = new ApiService();

// Exportar inst√¢ncia e fun√ß√µes convenientes
export default apiService;
export const getVideoUrl = (filePath) => apiService.getVideoUrl(filePath);
export const fileExists = (filePath) => apiService.fileExists(filePath);
export const getSystemInfo = () => apiService.getSystemInfo();
export const getCpuUsage = () => apiService.getCpuUsage();
export const forceQuitApp = () => apiService.forceQuitApp();
export const onAppClosing = (callback) => apiService.onAppClosing(callback);
export const getVideoSource = (filePath) => apiService.getVideoSource(filePath);
export const saveProject = (projectData, filePath) => apiService.saveProject(projectData, filePath);
export const getCapabilities = () => apiService.getCapabilities();
export const isApiReady = () => apiService.isReady();
export const getEnvironmentMessage = () => apiService.getEnvironmentMessage();